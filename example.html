<!DOCTYPE html>
<html lang="id">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>PFP Twibbon</title>
<style>
    body {
        font-family: sans-serif;
        background: #f0f0f0;
        margin: 0;
        padding: 20px;
        display: flex;
        justify-content: center;
    }
    .drop-area {
        width: 100%;
        max-width: 400px;
        aspect-ratio: 1/1;
        border: 2px dashed #aaa;
        background: #fff;
        display: flex;
        align-items: center;
        justify-content: center;
        flex-direction: column;
        position: relative;
        overflow: hidden;
        border-radius: 10px;
        transition: background 0.3s;
    }
    .drop-area.hover {
        background: #f8f8f8;
        border-color: #555;
    }
    .drop-text {
        text-align: center;
        color: #777;
    }
    canvas {
        position: absolute;
        top: 0;
        left: 0;
    }
    input[type=file] {
        display: none;
    }
</style>
</head>
<body>

<div class="drop-area" id="dropArea">
    <p class="drop-text" id="dropText">Tarik & Lepas Gambar atau Klik</p>
    <input type="file" id="fileInput" accept="image/*">
    <canvas id="canvas"></canvas>
</div>

<script>
const dropArea = document.getElementById('dropArea');
const dropText = document.getElementById('dropText');
const fileInput = document.getElementById('fileInput');
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

let userImage = null;
let twibbonImage = new Image();
let scale = 1;
let offsetX = 0, offsetY = 0;
let lastTouchDistance = null;
let lastTouchX = null, lastTouchY = null;
let isDragging = false;
let isInteracting = false;

twibbonImage.src = "twibbon.png"; // ganti dengan path twibbon kamu

// === Event untuk drag & drop ===
dropArea.addEventListener('click', () => fileInput.click());
dropArea.addEventListener('dragover', e => {
    e.preventDefault();
    dropArea.classList.add('hover');
});
dropArea.addEventListener('dragleave', () => dropArea.classList.remove('hover'));
dropArea.addEventListener('drop', e => {
    e.preventDefault();
    dropArea.classList.remove('hover');
    handleFile(e.dataTransfer.files[0]);
});
fileInput.addEventListener('change', e => {
    handleFile(e.target.files[0]);
});

function handleFile(file) {
    if (!file || !file.type.startsWith('image/')) return;
    const reader = new FileReader();
    reader.onload = () => {
        userImage = new Image();
        userImage.onload = () => {
            initCanvas();
            dropText.style.display = 'none';
            fileInput.disabled = true; // nonaktifkan unggah ulang
        };
        userImage.src = reader.result;
    };
    reader.readAsDataURL(file);
}

function initCanvas() {
    canvas.width = dropArea.clientWidth;
    canvas.height = dropArea.clientHeight;
    offsetX = 0;
    offsetY = 0;
    scale = 1;
    draw();
}

// === Gambar ulang canvas ===
function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    if (userImage) {
        let imgW = userImage.width * scale;
        let imgH = userImage.height * scale;
        let x = canvas.width/2 - imgW/2 + offsetX;
        let y = canvas.height/2 - imgH/2 + offsetY;
        ctx.drawImage(userImage, x, y, imgW, imgH);
    }
    if (userImage) {
        ctx.globalAlpha = isInteracting ? 0.5 : 1; // transparan saat interaksi
        ctx.drawImage(twibbonImage, 0, 0, canvas.width, canvas.height);
        ctx.globalAlpha = 1;
    }
}

// === Gesture handling ===
canvas.addEventListener('touchstart', e => {
    if (e.touches.length === 1) {
        isDragging = true;
        lastTouchX = e.touches[0].clientX;
        lastTouchY = e.touches[0].clientY;
    } else if (e.touches.length === 2) {
        lastTouchDistance = getDistance(e.touches[0], e.touches[1]);
    }
    isInteracting = true;
    draw();
});

canvas.addEventListener('touchmove', e => {
    e.preventDefault();
    if (e.touches.length === 1 && isDragging) {
        let dx = e.touches[0].clientX - lastTouchX;
        let dy = e.touches[0].clientY - lastTouchY;
        offsetX += dx;
        offsetY += dy;
        lastTouchX = e.touches[0].clientX;
        lastTouchY = e.touches[0].clientY;
    } else if (e.touches.length === 2) {
        let newDistance = getDistance(e.touches[0], e.touches[1]);
        if (lastTouchDistance) {
            scale *= newDistance / lastTouchDistance;
        }
        lastTouchDistance = newDistance;
    }
    draw();
}, { passive: false });

canvas.addEventListener('touchend', e => {
    if (e.touches.length === 0) {
        isDragging = false;
        isInteracting = false;
        draw();
    }
});

function getDistance(touch1, touch2) {
    let dx = touch2.clientX - touch1.clientX;
    let dy = touch2.clientY - touch1.clientY;
    return Math.sqrt(dx*dx + dy*dy);
}
</script>

</body>
</html>
