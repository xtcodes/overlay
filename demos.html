<!doctype html>
<html lang="id">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Alat Twibbon Responsif</title>
<style>
  :root{
    --panel-bg: rgba(0,0,0,0.6);
    --panel-fg: #fff;
    --accent: #4CAF50;
    --container-max: 900px;
  }
  body{
    font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
    margin:0;
    padding:18px;
    background:#f3f4f6;
    color:#111827;
    display:flex;
    align-items:flex-start;
    justify-content:center;
    min-height:100vh;
  }

  .wrap{
    width:100%;
    max-width: var(--container-max);
    box-shadow: 0 6px 18px rgba(15,23,42,0.08);
    border-radius:12px;
    background: #ffffff;
    padding:16px;
    box-sizing:border-box;
  }

  .canvas-area{
    position:relative;
    width:100%;
    /* maintain 4:3 aspect ratio by default, but responsive */
    padding-top:75%;
    background: linear-gradient(180deg,#eef2ff, #fff);
    border-radius:8px;
    overflow:hidden;
  }

  canvas{
    position:absolute;
    inset:0;
    width:100%;
    height:100%;
    display:block;
    background:transparent;
  }

  /* control panel anchored bottom-left of canvas */
  .control-panel{
    position:absolute;
    left:12px;
    bottom:12px;
    display:flex;
    gap:8px;
    flex-direction:column;
    background: var(--panel-bg);
    color:var(--panel-fg);
    padding:10px;
    border-radius:10px;
    box-shadow: 0 6px 18px rgba(2,6,23,0.2);
    backdrop-filter: blur(6px);
    z-index:30;
    min-width:170px;
  }

  .control-panel .row{
    display:flex;
    gap:8px;
    align-items:center;
  }

  .control-panel label{
    font-size:13px;
    color: #f8fafc;
  }

  .control-panel input[type="file"]{
    display:none;
  }

  .btn{
    appearance:none;
    border:none;
    padding:8px 10px;
    background:rgba(255,255,255,0.08);
    color:inherit;
    border-radius:8px;
    cursor:pointer;
    font-size:13px;
  }
  .btn.primary{
    background:var(--accent);
    color:white;
  }
  .small{
    font-size:12px;
    padding:6px 8px;
  }

  .controls-bottom{
    margin-top:12px;
    display:flex;
    gap:8px;
    justify-content:space-between;
    align-items:center;
  }

  .sliders{
    display:flex;
    gap:6px;
    align-items:center;
    margin-top:8px;
  }
  .sliders input[type="range"]{
    width:120px;
  }

  .meta{
    margin-top:12px;
    display:flex;
    gap:8px;
    align-items:center;
    justify-content:flex-end;
  }

  .info{
    font-size:13px;
    color:#374151;
  }

  /* small screens adjust */
  @media (max-width:520px){
    .control-panel{
      left:8px;
      bottom:8px;
      min-width:150px;
      padding:8px;
    }
    .sliders input[type="range"]{ width:92px; }
  }
</style>
</head>
<body>
  <div class="wrap" role="main">
    <h2 style="margin:6px 0 12px 0">Alat Twibbon â€” Responsive Canvas</h2>

    <div class="canvas-area" id="canvasArea">
      <canvas id="mainCanvas" aria-label="Canvas Twibbon"></canvas>

      <!-- Control panel bottom-left -->
      <div class="control-panel" id="controlPanel" aria-hidden="false">
        <div class="row">
          <label for="photoInput">Foto:</label>
          <button class="btn small" id="photoBtn">Pilih</button>
          <input id="photoInput" type="file" accept="image/*">
        </div>

        <div class="row">
          <label for="frameInput">Twibbon (PNG):</label>
          <button class="btn small" id="frameBtn">Pilih</button>
          <input id="frameInput" type="file" accept="image/png,image/*">
        </div>

        <div class="row">
          <label for="fontInput">Font:</label>
          <button class="btn small" id="fontBtn">Unggah</button>
          <input id="fontInput" type="file" accept=".ttf,.otf,.woff,.woff2">
        </div>

        <div class="sliders" title="Atur posisi & ukuran foto">
          <div style="font-size:12px;color:#fff;">Scale</div>
          <input id="scaleRange" type="range" min="0.2" max="2.5" step="0.01" value="1">
        </div>

        <div class="sliders">
          <div style="font-size:12px;color:#fff;">Rotate</div>
          <input id="rotateRange" type="range" min="-180" max="180" step="1" value="0">
        </div>

        <div style="display:flex;gap:6px;align-items:center;margin-top:6px;">
          <input id="textInput" type="text" placeholder="Tulis teks..." style="flex:1;padding:6px;border-radius:6px;border:none;font-size:13px;">
        </div>

        <div class="controls-bottom">
          <div style="display:flex;gap:6px;">
            <button class="btn" id="resetBtn" title="Reset posisi dan konten">Reset</button>
            <button class="btn" id="undoBtn" title="Undo terakhir">Undo</button>
          </div>
          <div style="display:flex;gap:6px;">
            <button class="btn primary" id="downloadBtn" title="Unduh PNG">Unduh</button>
          </div>
        </div>
      </div>
    </div>

    <div style="margin-top:12px;display:flex;justify-content:space-between;align-items:center;">
      <div class="info">Tips: seret foto langsung di kanvas untuk memindahkan. Gunakan slider untuk scale & rotate.</div>
      <div style="font-size:13px;color:#6b7280">Output: PNG (transparent jika frame/overlay ada area transparan)</div>
    </div>
  </div>

<script>
/*
  Twibbon Tool JS
  - responsive canvas with devicePixelRatio support
  - load user photo, load frame (twibbon) PNG, load font via FontFace
  - allow dragging photo, scale & rotate via range inputs
  - editable text using uploaded font; text rendered at center-bottom by default
  - download final PNG
*/

// --- Helpers ---
const $ = id => document.getElementById(id);

// Canvas setup
const canvas = $('mainCanvas');
const ctx = canvas.getContext('2d', { alpha: true });
const container = document.getElementById('canvasArea');

let DPR = window.devicePixelRatio || 1;

// scene state
const state = {
  photo: { img: null, x: 0, y: 0, scale: 1, rotation: 0, w:0, h:0 },
  frame: { img: null },
  text: { value: '', fontFamily: 'sans-serif', size: 40, x: 0.5, y: 0.9, color: '#ffffff' },
  history: []
};

// responsive: set canvas size to container size * DPR
function resizeCanvas(){
  const rect = container.getBoundingClientRect();
  const cssW = Math.max(200, rect.width);
  const cssH = Math.max(150, rect.height);
  DPR = window.devicePixelRatio || 1;
  canvas.style.width = cssW + 'px';
  canvas.style.height = cssH + 'px';
  canvas.width = Math.round(cssW * DPR);
  canvas.height = Math.round(cssH * DPR);
  draw();
}

// save state to history (shallow clone)
function pushHistory(){
  const snap = {
    photo: {...state.photo},
    text: {...state.text},
    frame: state.frame.img ? state.frame.img.src : null
  };
  state.history.push(snap);
  if(state.history.length > 30) state.history.shift();
}

// undo
function undo(){
  if(state.history.length === 0) return;
  const last = state.history.pop();
  state.photo = {...state.photo, ...last.photo};
  state.text = {...state.text, ...last.text};
  if(last.frame){
    const img = new Image();
    img.onload = () => { state.frame.img = img; draw(); };
    img.src = last.frame;
  } else {
    state.frame.img = null;
  }
  draw();
}

// draw scene
function draw(){
  if(!ctx) return;
  // clear
  ctx.clearRect(0,0,canvas.width,canvas.height);

  // background: optional light checker to show transparency?
  // (commented out)
  // draw photo
  const cW = canvas.width, cH = canvas.height;

  // photo: draw centered with transforms
  if(state.photo.img){
    ctx.save();
    // center of canvas in pixels
    const cx = cW * 0.5;
    const cy = cH * 0.5;
    ctx.translate(cx + state.photo.x * DPR, cy + state.photo.y * DPR);
    ctx.rotate(state.photo.rotation * Math.PI / 180);
    ctx.scale(state.photo.scale * DPR, state.photo.scale * DPR);

    // draw image centered at 0,0 with its intrinsic size
    const w = state.photo.w;
    const h = state.photo.h;
    ctx.drawImage(state.photo.img, -w/2, -h/2, w, h);

    ctx.restore();
  } else {
    // optional placeholder
    ctx.save();
    ctx.fillStyle = '#f8fafc';
    ctx.fillRect(0,0,cW,cH);
    ctx.restore();
  }

  // draw text (centered by relative positions)
  if(state.text.value){
    ctx.save();
    const px = Math.round(cW * state.text.x);
    const py = Math.round(cH * state.text.y);
    const fontSizePx = Math.round(state.text.size * DPR);
    ctx.font = `${fontSizePx}px "${state.text.fontFamily}", sans-serif`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    // stroke for readability
    ctx.lineWidth = Math.max(2, Math.round(fontSizePx * 0.08));
    ctx.strokeStyle = 'rgba(0,0,0,0.4)';
    ctx.fillStyle = state.text.color;
    ctx.strokeText(state.text.value, px, py);
    ctx.fillText(state.text.value, px, py);
    ctx.restore();
  }

  // draw frame (twibbon) on top
  if(state.frame.img){
    ctx.save();
    // draw frame stretched to cover canvas (respect device pixel)
    ctx.drawImage(state.frame.img, 0, 0, cW, cH);
    ctx.restore();
  }
}

// --- Input handling ---

// photo upload
$('photoBtn').addEventListener('click', ()=> $('photoInput').click());
$('photoInput').addEventListener('change', async (ev)=>{
  const f = ev.target.files && ev.target.files[0];
  if(!f) return;
  const url = URL.createObjectURL(f);
  const img = new Image();
  img.onload = ()=>{
    // fit image to canvas dimension but keep aspect
    // we'll store original drawn w/h such that the image fills the canvas shortest side
    const cW = canvas.width / DPR;
    const cH = canvas.height / DPR;
    // scale image to cover canvas (cover strategy)
    const scale = Math.max(cW / img.width, cH / img.height);
    state.photo.img = img;
    state.photo.w = img.width * scale;
    state.photo.h = img.height * scale;
    state.photo.x = 0;
    state.photo.y = 0;
    state.photo.scale = 1;
    state.photo.rotation = 0;
    pushHistory();
    draw();
    URL.revokeObjectURL(url);
  };
  img.src = url;
});

// frame upload (twibbon overlay)
$('frameBtn').addEventListener('click', ()=> $('frameInput').click());
$('frameInput').addEventListener('change', (ev)=>{
  const f = ev.target.files && ev.target.files[0];
  if(!f) return;
  const url = URL.createObjectURL(f);
  const img = new Image();
  img.onload = ()=>{
    // ensure PNG with transparency ideally; we just draw it stretched
    state.frame.img = img;
    pushHistory();
    draw();
    URL.revokeObjectURL(url);
  };
  img.src = url;
});

// font upload
$('fontBtn').addEventListener('click', ()=> $('fontInput').click());
$('fontInput').addEventListener('change', async (ev)=>{
  const f = ev.target.files && ev.target.files[0];
  if(!f) return;
  const name = f.name.replace(/\s+/g,'_').replace(/\.[^.]+$/, '');
  const reader = new FileReader();
  reader.onload = async (e)=>{
    try{
      const fontData = e.target.result;
      const fontFace = new FontFace(name, fontData);
      // load & add
      await fontFace.load();
      document.fonts.add(fontFace);
      state.text.fontFamily = name;
      pushHistory();
      draw();
      alert('Font berhasil diunggah dan diterapkan ke teks.');
    }catch(err){
      console.error(err);
      alert('Gagal memuat font. Pastikan file font valid (ttf/otf/woff).');
    }
  };
  // read as ArrayBuffer then wrap as binary data URL
  reader.readAsArrayBuffer(f);

  // Note: For wider browser support, you could also create a blob URL and @font-face rule.
});

// scale & rotate inputs
$('scaleRange').addEventListener('input', (e)=>{
  state.photo.scale = parseFloat(e.target.value);
  draw();
});
$('rotateRange').addEventListener('input', (e)=>{
  state.photo.rotation = parseFloat(e.target.value);
  draw();
});

// text input
$('textInput').addEventListener('input', (e)=>{
  state.text.value = e.target.value;
  pushHistory();
  draw();
});

// download
$('downloadBtn').addEventListener('click', ()=>{
  // Export canvas as PNG with devicePixel handled already
  canvas.toBlob((blob)=>{
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = 'twibbon.png';
    document.body.appendChild(a);
    a.click();
    a.remove();
  }, 'image/png');
});

// reset
$('resetBtn').addEventListener('click', ()=>{
  if(confirm('Reset seluruh konten (foto, frame, teks)?')) {
    state.photo = { img:null, x:0, y:0, scale:1, rotation:0, w:0, h:0 };
    state.frame = { img:null };
    state.text = { value:'', fontFamily:'sans-serif', size:40, x:0.5, y:0.9, color:'#ffffff' };
    state.history = [];
    $('textInput').value = '';
    $('scaleRange').value = 1;
    $('rotateRange').value = 0;
    draw();
  }
});

// undo
$('undoBtn').addEventListener('click', undo);

// drag photo with mouse/touch
let dragging = false;
let lastPointer = null;

function screenToCanvasCoords(clientX, clientY){
  const rect = canvas.getBoundingClientRect();
  const x = clientX - rect.left - rect.width/2; // relative to center
  const y = clientY - rect.top - rect.height/2;
  // convert to logical px (not CSS px)
  return { x: x / DPR, y: y / DPR };
}

function onPointerDown(ev){
  if(!state.photo.img) return;
  ev.preventDefault();
  dragging = true;
  lastPointer = ev;
  // push state for undo only once per drag start
  pushHistory();
}

function onPointerMove(ev){
  if(!dragging || !lastPointer) return;
  ev.preventDefault();
  // compute delta in CSS px, convert to canvas logical px
  const dx = (ev.clientX - lastPointer.clientX) / DPR;
  const dy = (ev.clientY - lastPointer.clientY) / DPR;
  // update photo state position
  // note: photo.x,y are in logical px offsets relative to center
  state.photo.x += dx;
  state.photo.y += dy;
  lastPointer = ev;
  draw();
}

function onPointerUp(ev){
  if(!dragging) return;
  dragging = false;
  lastPointer = null;
}

canvas.addEventListener('mousedown', onPointerDown);
window.addEventListener('mousemove', onPointerMove);
window.addEventListener('mouseup', onPointerUp);

// touch support
canvas.addEventListener('touchstart', (e)=>{
  if(e.touches.length === 1){
    const t = e.touches[0];
    onPointerDown({clientX: t.clientX, clientY: t.clientY, preventDefault: ()=>e.preventDefault()});
  } else if(e.touches.length === 2){
    // simple pinch to scale
    // store initial distance and scale
    const a = e.touches[0], b = e.touches[1];
    const startDist = Math.hypot(a.clientX - b.clientX, a.clientY - b.clientY);
    const startScale = state.photo.scale;
    const onMove = (ev)=>{
      if(ev.touches.length !== 2) return;
      const a2 = ev.touches[0], b2 = ev.touches[1];
      const dist2 = Math.hypot(a2.clientX - b2.clientX, a2.clientY - b2.clientY);
      const ratio = dist2 / startDist;
      state.photo.scale = Math.max(0.2, Math.min(3, startScale * ratio));
      $('scaleRange').value = state.photo.scale;
      draw();
    };
    const onEnd = ()=>{ window.removeEventListener('touchmove', onMove); window.removeEventListener('touchend', onEnd); };
    window.addEventListener('touchmove', onMove, {passive:false});
    window.addEventListener('touchend', onEnd);
  }
}, {passive:false});


// resize handling
window.addEventListener('resize', resizeCanvas);

// initial setup
function init(){
  resizeCanvas();

  // show a simple default frame-ish placeholder? skip.

  // default text font size relative to canvas
  state.text.size = Math.max(24, Math.round((canvas.width / DPR) * 0.06));
  draw();
}

init();

// keyboard shortcuts (optional)
window.addEventListener('keydown', (e)=>{
  if(e.key === 'z' && (e.ctrlKey || e.metaKey)){
    e.preventDefault();
    undo();
  }
  if(e.key === 's' && (e.ctrlKey || e.metaKey)){
    e.preventDefault();
    $('downloadBtn').click();
  }
});
</script>
</body>
</html>
